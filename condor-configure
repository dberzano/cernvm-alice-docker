#!/bin/bash

# This has to be run inside the container

set -e

# Configuration

condor_secret="@CONDOR_SECRET@"
condor_head='alidbz.cern.ch'
#condor_head='172.17.42.1'

# ifconfig
ifconfig eth0

# Remove other configurations
rm -rvf /etc/condor/config.d/*

# Echoing local config before killing it
echo "=== condor_config.local ==="
cat /etc/condor/condor_config.local | grep -v '^#' | sed -e '/^$/d'
echo "=== /condor_config.local ==="
echo
echo '# Blanked out' > /etc/condor/condor_config.local

# Add "our" configuration
cat > /etc/condor/config.d/70docker <<_EoF_
DAEMON_LIST = MASTER, STARTD

# Note that CONDOR_HOST is NOT this host, it's the remote one!
CONDOR_HOST = ${condor_head}
CONDOR_ADMIN = ${condor_head}

# Use CCB
#SHARED_PORT_ARGS = -p 9618
#DAEMON_LIST = \$(DAEMON_LIST), SHARED_PORT
#COLLECTOR_HOST = \$(CONDOR_HOST)?sock=collector
#USE_SHARED_PORT = True
CCB_ADDRESS = \$(CONDOR_HOST)

# Force one job slot (it is however sufficient to hack /proc/cpuinfo)
NUM_CPUS=1

# A hook to be executed when the job stops
POPPAMELO_HOOK_JOB_EXIT = /condor-hook-job-exit
STARTER_JOB_HOOK_KEYWORD = POPPAMELO

UID_DOMAIN = *
TRUST_UID_DOMAIN = True
SOFT_UID_DOMAIN = True
QUEUE_SUPER_USERS = root, condor
HIGHPORT = 42000
LOWPORT = 41000
SEC_DAEMON_AUTHENTICATION = required
SEC_DAEMON_INTEGRITY = required
SEC_DAEMON_AUTHENTICATION_METHODS = password
SEC_CLIENT_AUTHENTICATION_METHODS = password,fs,gsi,kerberos
SEC_PASSWORD_FILE = /etc/condor/condor_credential
SEC_ENABLE_MATCH_PASSWORD_AUTHENTICATION = True
ALLOW_DAEMON = condor_pool@*, submit-side@matchsession
COLLECTOR_NAME = Condor cluster at ${condor_head}
NEGOTIATOR_INTERVAL = 20
START = TRUE
SUSPEND = FALSE
PREEMPT = FALSE
KILL = FALSE
TRUST_UID_DOMAIN = TRUE
UPDATE_COLLECTOR_WITH_TCP = True
COLLECTOR_SOCKET_CACHE_SIZE = 1000
# this is needed to set the path
#USER_JOB_WRAPPER = /etc/condor/job_wrapper.sh
# this is a dummy value to prevent job killing for consuming too much mem
JOB_DEFAULT_REQUESTMEMORY = 42
_EoF_

# NO_DNS?
#IpAddress=$( ifconfig eth0 | grep 'inet addr:' | sed -e 's/\s*inet addr:// ; s/\s.*$//' )
#cat >> /etc/condor/condor_config <<_EoF_
#NETWORK_INTERFACE = $IpAddress
#NO_DNS = True
#DEFAULT_DOMAIN_NAME = condor-docker
#_EoF_

# Configure Condor password
condor_store_cred add -c -p "$condor_secret"

# Start Condor
service condor start

echo "100"

# Wait one second and check if we have the PID
sleep 1
echo "200"
condor_master_pidfile=/var/run/condor/condor.pid
echo "300"
condor_master_pid=$( cat "$condor_master_pidfile" 2> /dev/null )
echo "400"

# Check if PID is valid
if [[ $condor_master_pid -le 0 ]] ; then
  # Bash maps invalid strings to 0 so if $condor_head is invalid, it is -eq 0 (but not == 0)
  echo "FATAL: Invalid PID: ${condor_master_pid}"
  exit 1
fi

# Check if we can ping the process
if ! kill -0 $condor_master_pid > /dev/null 2>&1 ; then
  echo "FATAL: Cannot find condor_master process with PID ${condor_master_pid}"
  exit 2
fi

# Acknowledge the PID
echo "OK: condor_master is running with PID ${condor_master_pid}"

# Wait a bit before invoking the condor_off. Pilot waits for things to come!
pilot_sleep_s=120
echo "Waiting ${pilot_sleep_s} seconds for jobs to come"
sleep $pilot_sleep_s

# Peacefully turning the master off. Master controls startd. "Peacefully" means that no turn off
# will occur until every running job has finished. So, if no job is running, exit immediately
condor_off -daemon master -peaceful

# Begin the wait...
condor_master_ping_s=4
echo -n "Checking every ${condor_master_ping_s} s if condor_master has terminated"
while [[ 1 ]] ; do

  echo -n '.'

  kill -0 $condor_master_pid > /dev/null 2>&1

  if [[ $? != 0 ]] ; then
    echo 'exited!'
  fi

  sleep $condor_master_ping_s

done

echo 'SUCCESS: Terminating container...'
exit 0

# Logs
#sleep 1
#tail -f /var/log/condor/*
