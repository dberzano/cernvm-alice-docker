#!/bin/bash

# docker-cernvm -- by Dario Berzano <dario.berzano@cern.ch>
#
# Using Docker overlay with the CernVM operating system

# Color definitions
export Cc="\033[36m"
export Cm="\033[35m"
export Cy="\033[33m"
export Cb="\033[34m"
export Cr="\033[31m"
export Cg="\033[32m"
export Cz="\033[m"

# Automatic variables (do not edit)
prog="$( basename "$0" )"
exec_prefix="$( dirname "$0" )"
exec_prefix="$( cd "$exec_prefix" ; pwd )"
dry=0

# General-purpose variables
cvm_root='/cvmfs/cernvm-prod.cern.ch/cvm3'
cvm_docker_build_dir="${exec_prefix}/docker-build"
docker_prefix='/var/lib/docker'
cvm_placeholder='THIS_IS_A_CERNVM_MOUNT_POINT'

# Echo
function pe() (
  echo -e "$@" >&2
)

# Echo without newline
function pen() (
  echo -e -n "$@" >&2
)

# Wrap a command, prints it on screen before executing it. Execute it for real
# only if dry=0. Preserve its exit state.
#
# Usage: wrap [opts] <msg> <cmd> [param1 [param2 [param3...]]]
function wrap() {
  local r
  local err=$(mktemp)
  local out
  local msg
  local preserve_out=0
  local non_fatal=0

  while [[ $# -gt 0 ]] ; do
    case "$1" in
      --out) preserve_out=1 ; shift ;;
      --non-fatal) non_fatal=1 ; shift ;;
      *) break ;;
    esac
  done

  [[ $preserve_out == 0 ]] && out=$(mktemp)

  msg="$1"
  shift

  pen "[....] ${Cc}${msg}${Cz}"

  # Dry run?
  if [[ $dry == 0 ]] ; then
    if [[ $preserve_out == 1 ]] ; then
      # Keep output on stdout
      "$@" 2> "$err"
      r=$?
    else
      "$@" > "$out" 2> "$err"
      r=$?
    fi
  else
    r=0
  fi

  if [[ $dry == 1 ]] ; then
    pe "\r[${Cy}FAKE${Cz}]"
  elif [[ $r == 0 ]] ; then
    pe "\r[ ${Cg}OK${Cz} ]"
  elif [[ $non_fatal == 1 ]] ; then
    # Erred, but it was non-fatal
    pe "\r[${Cy}SKIP${Cz}]"
  else
    pe "\r[${Cr}FAIL${Cz}]"

    pe "\n${Cy}=== COMMAND FAILED === ${Cz}"
    pe "${Cm}Command: ${Cr}${@}${Cz}"
    pe "${Cm}Exit code: ${Cr}${r}${Cz}"

    if [[ $out != '' && -s $out ]] ; then
      pe "\n${Cy}=== STDOUT === ${Cz}"
      cat "$out" >&2
    fi

    if [[ -s $err ]] ; then
      pe "\n${Cy}=== STDERR === ${Cz}"
      cat "$err" >&2
    fi

    pe ''
  fi

  rm -f "$err"
  [[ $out != '' ]] && rm -f "$out"

  return $r
}

# Gets the image id.
function get_image_id() (
  local repotag="$1"
  local tag=$( echo "$repotag" | cut -d: -f2 )
  local repo=$( echo "$repotag" | cut -d: -f1 )
  local image_id
  if [[ $tag == '' ]] ; then
    repotag="${repo}:latest"
  fi
  image_id=$( docker images -q --no-trunc "$repotag" )
  r=$?
  if [[ $image_id == '' || $r != 0 ]] ; then
    return 1
  fi
  echo "$image_id"
  return 0
)

# Register a dummy Docker CernVM image, to be used later as a disposable one.
# $1: repository[:tag], in Docker's format
function dcvm_register() (
  local tag="$1"
  local image_id
  local r
  wrap "Registering CernVM dummy image to Docker as \"$tag\"" \
    docker build --tag "$tag" "$cvm_docker_build_dir"
  r=$?
  if [[ $r == 0 ]] ; then
    image_id=$( wrap --out "Fetching Image ID for \"${tag}\"" get_image_id "${tag}" )
    r=$?
    if [[ $r == 0 ]] ; then
      pe "Image ${Cc}${tag}${Cz} registered as ${Cg}${image_id}${Cz}"
    fi
  fi
  return $r
)

# Mount the CernVM mount point on top of the Docker layer adding the dummy file.
# $1: repository[:tag], in Docker's format
function dcvm_mount() (
  local tag="$1"
  local image_id
  local layers
  local layer_path
  local found
  local already_mounted
  local r

  image_id=$( wrap --out "Fetching Image ID for \"${tag}\"" get_image_id "${tag}" )
  [[ $? == 0 ]] || return 1

  # Fetch the list of layers
  layers=$( wrap --out "Fetching layers for ${image_id}" cat ${docker_prefix}/aufs/layers/${image_id} )
  [[ $? == 0 ]] || return 1

  # Append our current image to the list of layers to inspect
  layers="${layers} ${image_id}"

  found=0
  already_mounted=0
  for layer_id in $layers ; do

    layer_path="${docker_prefix}/aufs/diff/${layer_id}"

    if cat /proc/mounts 2> /dev/null | grep -q "$layer_path" ; then
      # This layer is already mounted
      found=1
      already_mounted=1
      break
    elif [[ -e "${layer_path}/${cvm_placeholder}" ]] ; then
      # Not yet mounted
      found=1
      already_mounted=0
      break
    fi
  done

  if [[ $found == 0 ]] ; then
    pe "Cannot find a suitable layer to overlay with CernVM for ${Cr}${tag}${Cz}"
    r=1
  else
    # Mount operations here

    if [[ $already_mounted == 1 ]] ; then
      wrap --non-fatal "Layer ${layer_id} already mounted: trying to unmount first" \umount "$layer_path"
      [[ $? == 0 ]] && already_mounted=0
    fi

    if [[ $already_mounted == 0 ]] ; then
      wrap "Mounting CernVM root fs over ${layer_id}" \mount --bind "$cvm_root" "$layer_path"
      r=$?
      if [[ $r == 0 ]] ; then
        pe "Freshly mounted over layer ${Cg}${layer_id}${Cz}."
      fi
    else
      pe "Reusing existing mountpoint over layer ${Cy}${layer_id}${Cz}."
      r=0
    fi

  fi

  return $r
)

# The main function
function main() (

  local action
  local tag
  local r

  while [[ $# -gt 0 ]] ; do
    case "${1}" in
      --tag)
        tag="$2"
        shift 2
      ;;
      *)
        break
      ;;
    esac
  done

  action="$1"
  if [[ $action == register || $action == run || $action == mount ]] ; then
    if [[ $tag == '' ]] ; then
      pe "Argument ${Cr}--tag${Cz} is mandatory."
      r=1
    else
      dcvm_$action "$tag"
      r=$?
    fi
  else
    pe "Action unknown or unspecified: \"${Cr}${action}${Cz}\"."
    pe "Usage: ${Cm}${prog}${Cz} [${Cc}--tag ${Cm}<tagname>${Cz}] [${Cc}register${Cz}|${Cc}run${Cz}|${Cc}mount${Cz}]"
    r=1
  fi

  return $r
)

# Entry point
main "$@" || exit $?
